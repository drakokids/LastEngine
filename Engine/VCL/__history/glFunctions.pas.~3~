unit glFunctions;

interface

uses Classes,Windows,dglOpenGL,
    sdl2;

procedure glDrawScene;
procedure CloseOpenGL(GLHandle, GLUHandle: HINST);
function glResizeWindow( width : integer; height : integer ) : Boolean;
procedure glHandleKeyPress( keysym : PSDL_keysym );
function glTimer( interval : UInt32; param : Pointer ) : UInt32;
procedure Init_OpenGL;
procedure Quit_App;
procedure glHandleEvents;

const INVALID_MODULEHANDLE = 0;

var done        : Integer;
    WINDOWS_CAPTION     =  'Last Engine';
    SCREEN_BPP          = 32;
    FPS_INTERVAL        = 1000;
    surface     : PSDL_Surface;
    videoflags  : Uint32;
    FPSCount    : LongInt;
    GLHandle: HINST;
    GLUHandle: HINST;

implementation

procedure glDrawScene;
begin
  // Screen- und Tiefenbuffer bereinigen
  glClear( GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT );

  glLoadIdentity;
  glTranslatef( -1.5, 0.0, -6.0 );

  // Zeichne Dreieck
  glcolor3f(1,0,0);
  glBegin( GL_TRIANGLES );
    glVertex3f( 0.0, 1.0, 0.0 );
    glVertex3f( 1.0, -1.0, 0.0 );
    glVertex3f( -1.0, -1.0, 0.0 );
  glEnd;

  glTranslatef( 3.0, 0.0, 0.0 );

  // Zeichne ein Quadrat
  glcolor3f(0,1,0);
  glBegin( GL_QUADS );
    glVertex3f( -1.0, 1.0, 0.0 );
    glVertex3f( 1.0, 1.0, 0.0 );
    glVertex3f( 1.0, -1.0, 0.0 );
    glVertex3f( -1.0, -1.0, 0.0 );
  glEnd;

  // Buffer-Wechseln ==> Anzeigen
  SDL_GL_SwapBuffers;
end;

procedure CloseOpenGL(GLHandle, GLUHandle: HINST);
  begin
    if GLHandle <> INVALID_MODULEHANDLE then
    begin
      FreeLibrary(Cardinal(GLHandle));
      GLHandle := INVALID_MODULEHANDLE;
    end;

    if GLUHandle <> INVALID_MODULEHANDLE then
    begin
      FreeLibrary(Cardinal(GLUHandle));
      GLUHandle := INVALID_MODULEHANDLE;
    end;

//    ClearProcAddresses;
    ClearExtensions;
  end;

function glResizeWindow( width : integer; height : integer ) : Boolean;
begin
  // Verhindern von "Division by Zero"
  if ( height = 0 ) then height := 1;

  // Viewport und Projektions-Matrix aktualisieren
  glViewport( 0, 0, width, height );

  glMatrixMode( GL_PROJECTION );
    glLoadIdentity;
    gluPerspective( 45.0, width / height, 0.1, 100.0 );
  glMatrixMode( GL_MODELVIEW );

  // Rücksetzen der World-Matrix
  glLoadIdentity;

  // Vorgang erfolgreich
  result := true;
end;

procedure glHandleKeyPress( keysym : PSDL_keysym );
begin;
  case keysym.sym of
    SDLK_ESCAPE : done := -1;
  end;
end;

function glTimer( interval : UInt32; param : Pointer ) : UInt32;
begin;
    SDL_WM_SetCaption(
      pChar(
        WINDOWS_CAPTION + ' ['+IntToStr(Round(FPSCount * 1000/FPS_INTERVAL))+' FPS]') , nil);
    FPSCount := 0;
    Result := interval;
end;


procedure Init_OpenGL;
begin;
    // Laden und Initalisieren von OpenGL
//    LoadOpenGL;


    InitOpenGL;

 //   ActivateRenderingContext(
    ReadExtensions;

    // Ausganswerte für die State-Machine setzen
    glEnable(GL_TEXTURE_2D);	                // Aktiviert Texture Mapping
    glShadeModel(GL_SMOOTH);	                // Aktiviert weiches Shading
    glClearColor(0.0, 0.0, 0.0, 0.5);         // Bildschirm löschen (schwarz)
    glClearDepth(1.0);		                    // Depth Buffer Setup
    glEnable(GL_DEPTH_TEST);	                // Aktiviert Depth Testing
    glDepthFunc(GL_LEQUAL);	                  // Bestimmt den Typ des Depth Testing
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
                                              // Qualitativ bessere Koordinaten Interpolation
end;

procedure Init_SDL;
begin;
  // Initalisieren vom Simple DirectMedia Layer
  if ( SDL_Init( SDL_INIT_VIDEO ) < 0 ) then
  begin
    Log.LogError('Initalisierung von SDL schlug fehl: '+SDL_GetError,'SDL_Init');
    Quit_App;
  end;

  // Information über Grafikkarte einholen
  videoInfo := SDL_GetVideoInfo;
  if ( videoInfo = nil ) then
  begin
    Log.LogError('Grafikkarte liess sich nicht abfragen: '+SDL_GetError,'SDL_Init' );
    Quit_App;
  end;

  // Flags für den SDL-Grafikmodus setzen
  videoFlags := SDL_OPENGL or                  // OpenGL-Unterstützung aktivieren
                SDL_DOUBLEBUF or               // Double Buffering aktivieren
                SDL_HWPALETTE;                 // Palette in Hardware speichern

  // Kann die Surface in den Speicher?
  if ( videoInfo.hw_available <> 0 ) then
    videoFlags := videoFlags or SDL_HWSURFACE
  else
    videoFlags := videoFlags or SDL_SWSURFACE;

  // Wird hardware blitting unterstützt?
  if ( videoInfo.blit_hw <> 0 ) then videoFlags := videoFlags or SDL_HWACCEL;

  // Setzen der OpenGL-Attribute
  SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5 );
  SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 5 );
  SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5 );
  SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 );
  SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );

  // Fenstertitel festlegen
  SDL_WM_SetCaption( WINDOWS_CAPTION , nil);

  videoflags := videoFlags or SDL_RESIZABLE;    // Enable window resizing

  // Initalisierung der Surface
  surface := SDL_SetVideoMode( SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP,videoflags );
  if ( surface = nil ) then
  begin
    Log.LogError('Erzeugen einer OpenGL-Zeichenfläche schlug fehl: '+SDL_GetError,'SDL_Init' );
    Quit_App;
  end;

  // Initalisierung des Timers
  SDL_Init(SDL_INIT_TIMER);
end;

procedure Quit_App;
begin
  SDL_QUIT;
  CloseOpenGL(GLHandle,GLUHandle);
  Halt(0);
end;

procedure glHandleEvents;
var event       : TSDL_Event;
begin;
    // Verarbeiten der Events
    while ( SDL_PollEvent( @event ) = 1 ) do
    begin
      case event.type_ of

        // Beenden der Applikation
        SDL_QUITEV :
        begin
          Done := -1;
        end;

        // Taste wurde gedrückt
        SDL_KEYDOWN :
        begin
          glHandleKeyPress( @event.key.keysym );
        end;

        // Fenster-Größe hat sich verändert
        SDL_VIDEORESIZE :
        begin
          surface := SDL_SetVideoMode( event.resize.w, event.resize.h, SCREEN_BPP, videoflags );

          if ( surface = nil ) then
          begin
            Log.LogError('Surface bei Größenänderung verloren: '+SDL_GetError,'EVENT_RESIZE' );
            Quit_App;
          end;

          glResizeWindow( event.resize.w, event.resize.h );
        end;
      end;
    end;
end;
begin;
    SDL_WM_SetCaption(pChar( WINDOWS_CAPTION + ' ['+IntToStr(Round(FPSCount * 1000/FPS_INTERVAL))+' FPS]') , nil);
    FPSCount := 0;
    Result := interval;
end;


end.
